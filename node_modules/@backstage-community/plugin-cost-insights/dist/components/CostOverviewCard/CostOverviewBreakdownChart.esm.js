import React, { useState } from 'react';
import { DateTime } from 'luxon';
import Box from '@material-ui/core/Box';
import Divider from '@material-ui/core/Divider';
import { emphasize } from '@material-ui/core/styles/colorManipulator';
import Typography from '@material-ui/core/Typography';
import { useTheme } from '@material-ui/core/styles';
import FullScreenIcon from '@material-ui/icons/Fullscreen';
import { ResponsiveContainer, AreaChart, CartesianGrid, XAxis, YAxis, Tooltip, Area } from 'recharts';
import '../../types/Alert.esm.js';
import { DEFAULT_DATE_FORMAT } from '../../types/DateFormat.esm.js';
import { useCostOverviewStyles } from '../../utils/styles.esm.js';
import '@material-ui/core/Paper';
import '@material-ui/core/Slide';
import '@material-ui/icons/ChevronLeft';
import '@material-ui/icons/ChevronRight';
import '../BarChart/BarChartStepperButton.esm.js';
import '@material-ui/core/ButtonBase';
import { BarChartTooltip } from '../BarChart/BarChartTooltip.esm.js';
import { BarChartTooltipItem } from '../BarChart/BarChartTooltipItem.esm.js';
import { formatPeriod } from '../../utils/formatters.esm.js';
import { overviewGraphTickFormatter, formatGraphValue, isInvalid } from '../../utils/graphs.esm.js';
import { useConfig } from '../../hooks/useConfig.esm.js';
import '../../hooks/useCurrency.esm.js';
import { useFilters } from '../../hooks/useFilters.esm.js';
import '../../hooks/useGroups.esm.js';
import '../../hooks/useLoading.esm.js';
import '../../hooks/useScroll.esm.js';
import { useLastCompleteBillingDate } from '../../hooks/useLastCompleteBillingDate.esm.js';
import { BarChartLegend } from '../BarChart/BarChartLegend.esm.js';
import { mapFiltersToProps } from './selector.esm.js';
import { getPreviousPeriodTotalCost } from '../../utils/change.esm.js';
import { aggregationSum } from '../../utils/sum.esm.js';

const LOW_COST_THRESHOLD = 0.1;
const CostOverviewBreakdownChart = ({
  costBreakdown,
  responsive = true
}) => {
  const theme = useTheme();
  const classes = useCostOverviewStyles(theme);
  const { baseCurrency } = useConfig();
  const lastCompleteBillingDate = useLastCompleteBillingDate();
  const { duration } = useFilters(mapFiltersToProps);
  const [isExpanded, setExpanded] = useState(false);
  if (!costBreakdown) {
    return null;
  }
  const flattenedAggregation = costBreakdown.map((cost) => cost.aggregation).flat();
  const totalCost = aggregationSum(flattenedAggregation);
  const previousPeriodTotal = getPreviousPeriodTotalCost(
    flattenedAggregation,
    duration,
    lastCompleteBillingDate
  );
  const currentPeriodTotal = totalCost - previousPeriodTotal;
  const canExpand = costBreakdown.length >= 8;
  const otherCategoryIds = [];
  const breakdownsByDate = costBreakdown.reduce(
    (breakdownByDate, breakdown) => {
      const breakdownTotal = aggregationSum(breakdown.aggregation);
      const isOtherCategory = canExpand && breakdownTotal < totalCost * LOW_COST_THRESHOLD;
      const updatedBreakdownByDate = { ...breakdownByDate };
      if (isOtherCategory) {
        otherCategoryIds.push(breakdown.id);
      }
      breakdown.aggregation.forEach((curAggregation) => {
        const costsForDate = updatedBreakdownByDate[curAggregation.date] || {};
        updatedBreakdownByDate[curAggregation.date] = {
          ...costsForDate,
          [breakdown.id]: (costsForDate[breakdown.id] || 0) + curAggregation.amount
        };
      });
      return updatedBreakdownByDate;
    },
    {}
  );
  const chartData = Object.keys(breakdownsByDate).map((date) => {
    const costsForDate = Object.keys(breakdownsByDate[date]).reduce(
      (dateCosts, breakdown) => {
        const cost = breakdownsByDate[date][breakdown];
        const breakdownCost = !isExpanded && otherCategoryIds.includes(breakdown) ? { Other: (dateCosts.Other || 0) + cost } : { [breakdown]: cost };
        return { ...dateCosts, ...breakdownCost };
      },
      {}
    );
    return {
      ...costsForDate,
      date: Date.parse(date)
    };
  }).sort((a, b) => a.date - b.date);
  const sortedBreakdowns = costBreakdown.sort(
    (a, b) => aggregationSum(a.aggregation) - aggregationSum(b.aggregation)
  );
  const renderAreas = () => {
    const separatedBreakdowns = sortedBreakdowns.filter(
      (breakdown) => breakdown.id !== "Other" && !otherCategoryIds.includes(breakdown.id)
    ).map((breakdown) => breakdown.id);
    const breakdownsToDisplay = isExpanded ? sortedBreakdowns.map((breakdown) => breakdown.id) : ["Other", ...separatedBreakdowns];
    return breakdownsToDisplay.map((breakdown, i) => {
      const color = theme.palette.dataViz[(breakdownsToDisplay.length - 1 - i) % (theme.palette.dataViz.length - 1)];
      return /* @__PURE__ */ React.createElement(
        Area,
        {
          key: breakdown,
          dataKey: breakdown,
          isAnimationActive: false,
          stackId: "1",
          stroke: color,
          fill: color,
          onClick: () => setExpanded(true),
          style: {
            cursor: breakdown === "Other" && !isExpanded ? "pointer" : void 0
          }
        }
      );
    });
  };
  const tooltipRenderer = ({ label, payload = [] }) => {
    if (isInvalid({ label, payload })) return null;
    const date = typeof label === "number" ? DateTime.fromMillis(label) : DateTime.fromISO(label);
    const dateTitle = date.toUTC().toFormat(DEFAULT_DATE_FORMAT);
    const formatGraphValueWith = formatGraphValue(baseCurrency);
    const items = payload.map((p, i) => ({
      label: p.dataKey,
      value: formatGraphValueWith(Number(p.value), i),
      fill: p.color
    }));
    const expandText = /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(
      Divider,
      {
        style: {
          backgroundColor: emphasize(theme.palette.divider, 1),
          margin: "10px 0"
        }
      }
    ), /* @__PURE__ */ React.createElement(Box, { display: "flex", justifyContent: "space-between", alignItems: "center" }, /* @__PURE__ */ React.createElement(FullScreenIcon, null), /* @__PURE__ */ React.createElement(Typography, null, "Click to expand")));
    return /* @__PURE__ */ React.createElement(BarChartTooltip, { title: dateTitle }, items.reverse().map((item, index) => /* @__PURE__ */ React.createElement(BarChartTooltipItem, { key: `${item.label}-${index}`, item })), canExpand && !isExpanded ? expandText : null);
  };
  const options = {
    previousName: formatPeriod(duration, lastCompleteBillingDate, false),
    currentName: formatPeriod(duration, lastCompleteBillingDate, true),
    hideMarker: true
  };
  return /* @__PURE__ */ React.createElement(Box, { display: "flex", flexDirection: "column" }, /* @__PURE__ */ React.createElement(Box, { display: "flex", flexDirection: "row" }, /* @__PURE__ */ React.createElement(
    BarChartLegend,
    {
      costStart: previousPeriodTotal,
      costEnd: currentPeriodTotal,
      options
    }
  )), /* @__PURE__ */ React.createElement(
    ResponsiveContainer,
    {
      width: responsive ? "100%" : classes.container.width,
      height: classes.container.height
    },
    /* @__PURE__ */ React.createElement(
      AreaChart,
      {
        data: chartData,
        margin: {
          top: 16,
          right: 30,
          bottom: 40
        }
      },
      /* @__PURE__ */ React.createElement(CartesianGrid, { stroke: classes.cartesianGrid.stroke }),
      /* @__PURE__ */ React.createElement(
        XAxis,
        {
          dataKey: "date",
          domain: ["dataMin", "dataMax"],
          tickFormatter: overviewGraphTickFormatter,
          tickCount: 6,
          type: "number",
          stroke: classes.axis.fill
        }
      ),
      /* @__PURE__ */ React.createElement(
        YAxis,
        {
          domain: [() => 0, "dataMax"],
          tick: { fill: classes.axis.fill },
          tickFormatter: formatGraphValue(baseCurrency),
          width: classes.yAxis.width
        }
      ),
      renderAreas(),
      /* @__PURE__ */ React.createElement(Tooltip, { content: tooltipRenderer, animationDuration: 100 })
    )
  ));
};

export { CostOverviewBreakdownChart };
//# sourceMappingURL=CostOverviewBreakdownChart.esm.js.map
