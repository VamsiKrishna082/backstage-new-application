import React, { useRef, useState, useCallback, useEffect } from 'react';
import Box from '@material-ui/core/Box';
import Typography from '@material-ui/core/Typography';
import Alert from '@material-ui/lab/Alert';
import { costInsightsApiRef } from '../../api/CostInsightsApi.esm.js';
import { ProductInsightsCardList } from '../ProductInsightsCard/ProductInsightsCardList.esm.js';
import { intervalsOf, DEFAULT_DURATION } from '../../utils/duration.esm.js';
import { DefaultLoadingAction, settledResponseOf, initialStatesOf } from '../../utils/loading.esm.js';
import { totalAggregationSort } from '../../utils/sort.esm.js';
import '../../hooks/useConfig.esm.js';
import '../../hooks/useCurrency.esm.js';
import '../../hooks/useFilters.esm.js';
import '../../hooks/useGroups.esm.js';
import { useLoading } from '../../hooks/useLoading.esm.js';
import '../../hooks/useScroll.esm.js';
import { useLastCompleteBillingDate } from '../../hooks/useLastCompleteBillingDate.esm.js';
import { useApi } from '@backstage/core-plugin-api';

const mapLoadingToProps = ({ dispatch }) => (isLoading) => dispatch({ [DefaultLoadingAction.CostInsightsProducts]: isLoading });
const ProductInsights = ({
  group,
  project,
  products,
  onLoaded
}) => {
  const client = useApi(costInsightsApiRef);
  const onceRef = useRef(false);
  const [initialStates, setStates] = useState([]);
  const [error, setError] = useState(null);
  const lastCompleteBillingDate = useLastCompleteBillingDate();
  const dispatchLoading = useLoading(mapLoadingToProps);
  const dispatchLoadingProducts = useCallback(dispatchLoading, []);
  const onSelectAsyncMemo = useCallback(
    async function onSelectAsync(product, duration) {
      return client.getProductInsights({
        group,
        project,
        product: product.kind,
        intervals: intervalsOf(duration, lastCompleteBillingDate)
      });
    },
    [client, group, project, lastCompleteBillingDate]
  );
  useEffect(() => {
    async function getAllProductInsights() {
      try {
        dispatchLoadingProducts(true);
        const responses = await Promise.allSettled(
          products.map(
            (product) => client.getProductInsights({
              group,
              project,
              product: product.kind,
              intervals: intervalsOf(DEFAULT_DURATION, lastCompleteBillingDate)
            })
          )
        ).then(settledResponseOf);
        const updatedInitialStates = initialStatesOf(products, responses).sort(
          totalAggregationSort
        );
        setStates(updatedInitialStates);
      } catch (e) {
        setError(e);
      } finally {
        dispatchLoadingProducts(false);
      }
    }
    getAllProductInsights();
  }, [
    client,
    group,
    project,
    products,
    lastCompleteBillingDate,
    dispatchLoadingProducts
  ]);
  useEffect(
    function handleOnLoaded() {
      if (onceRef.current) {
        const initialProducts = initialStates.map((state) => state.product);
        onLoaded(initialProducts);
      } else {
        onceRef.current = true;
      }
    },
    [initialStates, onLoaded]
  );
  return /* @__PURE__ */ React.createElement(Box, { px: 3, py: 6 }, /* @__PURE__ */ React.createElement(Box, { mt: 0, mb: 5, textAlign: "center" }, /* @__PURE__ */ React.createElement(Typography, { variant: "h4", gutterBottom: true }, "Your team's product usage")), error ? /* @__PURE__ */ React.createElement(Alert, { severity: "error" }, error.message) : /* @__PURE__ */ React.createElement(
    ProductInsightsCardList,
    {
      initialStates,
      onSelectAsync: onSelectAsyncMemo
    }
  ));
};

export { ProductInsights };
//# sourceMappingURL=ProductInsights.esm.js.map
