import React, { useRef, useState, useCallback, useEffect } from 'react';
import pluralize from 'pluralize';
import Typography from '@material-ui/core/Typography';
import Alert from '@material-ui/lab/Alert';
import { PeriodSelect } from '../PeriodSelect/PeriodSelect.esm.js';
import { ProductInsightsChart } from './ProductInsightsChart.esm.js';
import { useProductInsightsCardStyles } from '../../utils/styles.esm.js';
import { DefaultLoadingAction } from '../../utils/loading.esm.js';
import '../../hooks/useConfig.esm.js';
import '../../hooks/useCurrency.esm.js';
import '../../hooks/useFilters.esm.js';
import '../../hooks/useGroups.esm.js';
import { useLoading } from '../../hooks/useLoading.esm.js';
import '../../hooks/useScroll.esm.js';
import { useLastCompleteBillingDate } from '../../hooks/useLastCompleteBillingDate.esm.js';
import { findAnyKey } from '../../utils/assert.esm.js';
import { ScrollAnchor } from '../../utils/scroll.esm.js';
import { InfoCard } from '@backstage/core-components';

const mapLoadingToProps = ({ dispatch }) => (isLoading) => dispatch({ [DefaultLoadingAction.CostInsightsProducts]: isLoading });
const ProductInsightsCard = ({
  initialState,
  product,
  onSelectAsync
}) => {
  const classes = useProductInsightsCardStyles();
  const mountedRef = useRef(false);
  const [error, setError] = useState(null);
  const dispatchLoading = useLoading(mapLoadingToProps);
  const lastCompleteBillingDate = useLastCompleteBillingDate();
  const [entity, setEntity] = useState(initialState.entity);
  const [duration, setDuration] = useState(initialState.duration);
  const dispatchLoadingProduct = useCallback(dispatchLoading, []);
  useEffect(() => {
    async function handleOnSelectAsync() {
      dispatchLoadingProduct(true);
      try {
        const e = await onSelectAsync(product, duration);
        setEntity(e);
      } catch (e) {
        setEntity(null);
        setError(e);
      } finally {
        dispatchLoadingProduct(false);
      }
    }
    if (mountedRef.current) {
      handleOnSelectAsync();
    } else {
      mountedRef.current = true;
    }
  }, [product, duration, onSelectAsync, dispatchLoadingProduct]);
  const entityKey = findAnyKey(entity?.entities);
  const entities = entityKey ? entity.entities[entityKey] : [];
  const subheader = entityKey && entities.length ? `${pluralize(entityKey, entities.length, true)}, sorted by cost` : null;
  const headerProps = {
    classes,
    action: /* @__PURE__ */ React.createElement(PeriodSelect, { duration, onSelect: setDuration })
  };
  if (error || !entity) {
    return /* @__PURE__ */ React.createElement(InfoCard, { title: product.name, headerProps }, /* @__PURE__ */ React.createElement(ScrollAnchor, { id: product.kind }), /* @__PURE__ */ React.createElement(Alert, { severity: "error" }, error ? error.message : `Error: Could not fetch product insights for ${product.name}`));
  }
  return /* @__PURE__ */ React.createElement(
    InfoCard,
    {
      title: product.name,
      subheader,
      headerProps
    },
    /* @__PURE__ */ React.createElement(ScrollAnchor, { id: product.kind }),
    entities.length ? /* @__PURE__ */ React.createElement(
      ProductInsightsChart,
      {
        entity,
        duration,
        billingDate: lastCompleteBillingDate
      }
    ) : /* @__PURE__ */ React.createElement(Typography, null, "There are no ", product.name, " costs within this time frame for your team's projects.")
  );
};

export { ProductInsightsCard };
//# sourceMappingURL=ProductInsightsCard.esm.js.map
