import { DateTime } from 'luxon';
import '../types/Alert.esm.js';
import { DEFAULT_DATE_FORMAT } from '../types/DateFormat.esm.js';
import { KubernetesMigrationAlert } from './alerts/KubernetesMigrationAlert.esm.js';
import { ProjectGrowthAlert } from '../alerts/ProjectGrowthAlert.esm.js';
import { UnlabeledDataflowAlert } from '../alerts/UnlabeledDataflowAlert.esm.js';
import '../testUtils/products.esm.js';
import '../testUtils/filters.esm.js';
import '../testUtils/loading.esm.js';
import 'react';
import '../hooks/useConfig.esm.js';
import '../hooks/useCurrency.esm.js';
import '../hooks/useFilters.esm.js';
import '../hooks/useGroups.esm.js';
import '../hooks/useLoading.esm.js';
import '../hooks/useScroll.esm.js';
import '../hooks/useLastCompleteBillingDate.esm.js';
import '../utils/currency.esm.js';
import { aggregationFor, changeOf, trendlineOf, getGroupedProducts, getGroupedProjects, entityOf } from '../testUtils/testUtils.esm.js';

class ExampleCostInsightsClient {
  request(_, res) {
    return new Promise((resolve) => setTimeout(resolve, 0, res));
  }
  getLastCompleteBillingDate() {
    return Promise.resolve(
      DateTime.now().minus({ days: 1 }).toFormat(DEFAULT_DATE_FORMAT)
    );
  }
  async getUserGroups(userId) {
    const groups = await this.request({ userId }, [
      { id: "group-a", name: "Group A" },
      { id: "group-b", name: "Group B" }
    ]);
    return groups;
  }
  async getGroupProjects(group) {
    const projects = await this.request({ group }, [
      { id: "project-a" },
      { id: "project-b" },
      { id: "project-c" }
    ]);
    return projects;
  }
  async getDailyMetricData(metric, intervals) {
    const aggregation = aggregationFor(intervals, 1e5).map((entry) => ({
      ...entry,
      amount: Math.round(entry.amount)
    }));
    const cost = await this.request(
      { metric, intervals },
      {
        format: "number",
        aggregation,
        change: changeOf(aggregation),
        trendline: trendlineOf(aggregation)
      }
    );
    return cost;
  }
  async getCatalogEntityDailyCost(entityRef, intervals) {
    const aggregation = aggregationFor(intervals, 8e3);
    const groupDailyCost = await this.request(
      { entityRef, intervals },
      {
        aggregation,
        change: changeOf(aggregation),
        trendline: trendlineOf(aggregation),
        // Optional field providing cost groupings / breakdowns keyed by the type. In this example,
        // daily cost grouped by cloud product OR by project / billing account.
        groupedCosts: {
          product: getGroupedProducts(intervals),
          project: getGroupedProjects(intervals)
        }
      }
    );
    return groupDailyCost;
  }
  async getGroupDailyCost(group, intervals) {
    const aggregation = aggregationFor(intervals, 8e3);
    const groupDailyCost = await this.request(
      { group, intervals },
      {
        aggregation,
        change: changeOf(aggregation),
        trendline: trendlineOf(aggregation),
        // Optional field providing cost groupings / breakdowns keyed by the type. In this example,
        // daily cost grouped by cloud product OR by project / billing account.
        groupedCosts: {
          product: getGroupedProducts(intervals),
          project: getGroupedProjects(intervals)
        }
      }
    );
    return groupDailyCost;
  }
  async getProjectDailyCost(project, intervals) {
    const aggregation = aggregationFor(intervals, 1500);
    const projectDailyCost = await this.request(
      { project, intervals },
      {
        id: "project-a",
        aggregation,
        change: changeOf(aggregation),
        trendline: trendlineOf(aggregation),
        // Optional field providing cost groupings / breakdowns keyed by the type. In this example,
        // daily project cost grouped by cloud product.
        groupedCosts: {
          product: getGroupedProducts(intervals)
        }
      }
    );
    return projectDailyCost;
  }
  async getProductInsights(options) {
    const productInsights = await this.request(
      options,
      entityOf(options.product)
    );
    return productInsights;
  }
  async getAlerts(group) {
    const projectGrowthData = {
      project: "example-project",
      periodStart: "2020-Q2",
      periodEnd: "2020-Q3",
      aggregation: [6e4, 12e4],
      change: {
        ratio: 1,
        amount: 6e4
      },
      products: [
        { id: "Compute Engine", aggregation: [58e3, 118e3] },
        { id: "Cloud Dataflow", aggregation: [1200, 1500] },
        { id: "Cloud Storage", aggregation: [800, 500] }
      ]
    };
    const unlabeledDataflowData = {
      periodStart: "2020-09-01",
      periodEnd: "2020-09-30",
      labeledCost: 6200,
      unlabeledCost: 7e3,
      projects: [
        {
          id: "example-project-1",
          unlabeledCost: 5e3,
          labeledCost: 3e3
        },
        {
          id: "example-project-2",
          unlabeledCost: 2e3,
          labeledCost: 3200
        }
      ]
    };
    const today = DateTime.now();
    const alerts = await this.request({ group }, [
      new ProjectGrowthAlert(projectGrowthData),
      new UnlabeledDataflowAlert(unlabeledDataflowData),
      new KubernetesMigrationAlert(this, {
        startDate: today.minus({ days: 30 }).toFormat(DEFAULT_DATE_FORMAT),
        endDate: today.toFormat(DEFAULT_DATE_FORMAT),
        change: {
          ratio: 0,
          amount: 0
        },
        services: [
          {
            id: "service-a",
            aggregation: [2e4, 1e4],
            change: {
              ratio: -0.5,
              amount: -1e4
            },
            entities: {}
          },
          {
            id: "service-b",
            aggregation: [3e4, 15e3],
            change: {
              ratio: -0.5,
              amount: -15e3
            },
            entities: {}
          }
        ]
      })
    ]);
    return alerts;
  }
}

export { ExampleCostInsightsClient };
//# sourceMappingURL=client.esm.js.map
