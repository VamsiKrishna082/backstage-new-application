import { DateTime } from 'luxon';
import regression from 'regression';
import '../types/Alert.esm.js';
import { DEFAULT_DATE_FORMAT } from '../types/DateFormat.esm.js';
import { inclusiveEndDateOf, inclusiveStartDateOf } from '../utils/duration.esm.js';
import { MockEventsInsights, MockBigQueryInsights, MockCloudStorageInsights, MockCloudDataflowInsights, MockComputeEngineInsights } from './mockData.esm.js';

function parseIntervals(intervals) {
  const match = intervals.match(
    /\/(?<duration>P\d+[DM])\/(?<date>\d{4}-\d{2}-\d{2})/
  );
  if (Object.keys(match?.groups || {}).length !== 2) {
    throw new Error(`Invalid intervals: ${intervals}`);
  }
  const { duration, date } = match.groups;
  return {
    duration,
    endDate: date
  };
}
function aggregationFor(intervals, baseline) {
  const { duration, endDate } = parseIntervals(intervals);
  const inclusiveEndDate = inclusiveEndDateOf(duration, endDate);
  const days = DateTime.fromISO(endDate).diff(
    DateTime.fromISO(inclusiveStartDateOf(duration, inclusiveEndDate)),
    "days"
  ).days;
  function nextDelta() {
    const varianceFromBaseline = 0.15;
    const positiveTrendChance = 0.55;
    const normalization = positiveTrendChance - 1;
    return baseline * (Math.random() + normalization) * varianceFromBaseline;
  }
  return [...Array(days).keys()].reduce(
    (values, i) => {
      const last = values.length ? values[values.length - 1].amount : baseline;
      const date = DateTime.fromISO(
        inclusiveStartDateOf(duration, inclusiveEndDate)
      ).plus({ days: i }).toFormat(DEFAULT_DATE_FORMAT);
      const amount = Math.max(0, last + nextDelta());
      values.push({
        date,
        amount
      });
      return values;
    },
    []
  );
}
function changeOf(aggregation) {
  const firstAmount = aggregation.length ? aggregation[0].amount : 0;
  const lastAmount = aggregation.length ? aggregation[aggregation.length - 1].amount : 0;
  if (!firstAmount || !lastAmount) {
    return {
      amount: lastAmount - firstAmount
    };
  }
  return {
    ratio: (lastAmount - firstAmount) / firstAmount,
    amount: lastAmount - firstAmount
  };
}
function trendlineOf(aggregation) {
  const data = aggregation.map((a) => [
    Date.parse(a.date) / 1e3,
    a.amount
  ]);
  const result = regression.linear(data, { precision: 5 });
  return {
    slope: result.equation[0],
    intercept: result.equation[1]
  };
}
function entityOf(product) {
  switch (product) {
    case "computeEngine":
      return MockComputeEngineInsights;
    case "cloudDataflow":
      return MockCloudDataflowInsights;
    case "cloudStorage":
      return MockCloudStorageInsights;
    case "bigQuery":
      return MockBigQueryInsights;
    case "events":
      return MockEventsInsights;
    default:
      throw new Error(
        `Cannot get insights for ${product}. Make sure product matches product property in app-info.yaml`
      );
  }
}
const getGroupedProducts = (intervals) => [
  {
    id: "Cloud Dataflow",
    aggregation: aggregationFor(intervals, 1700)
  },
  {
    id: "Compute Engine",
    aggregation: aggregationFor(intervals, 350)
  },
  {
    id: "Cloud Storage",
    aggregation: aggregationFor(intervals, 1300)
  },
  {
    id: "BigQuery",
    aggregation: aggregationFor(intervals, 2e3)
  },
  {
    id: "Cloud SQL",
    aggregation: aggregationFor(intervals, 750)
  },
  {
    id: "Cloud Spanner",
    aggregation: aggregationFor(intervals, 50)
  },
  {
    id: "Cloud Pub/Sub",
    aggregation: aggregationFor(intervals, 1e3)
  },
  {
    id: "Cloud Bigtable",
    aggregation: aggregationFor(intervals, 250)
  }
];
const getGroupedProjects = (intervals) => [
  {
    id: "project-a",
    aggregation: aggregationFor(intervals, 1700)
  },
  {
    id: "project-b",
    aggregation: aggregationFor(intervals, 350)
  },
  {
    id: "project-c",
    aggregation: aggregationFor(intervals, 1300)
  }
];

export { aggregationFor, changeOf, entityOf, getGroupedProducts, getGroupedProjects, trendlineOf };
//# sourceMappingURL=testUtils.esm.js.map
