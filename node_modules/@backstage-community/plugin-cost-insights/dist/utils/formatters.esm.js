import { DateTime, Duration as Duration$1 } from 'luxon';
import pluralize from 'pluralize';
import '../types/Alert.esm.js';
import { Duration } from '../types/Duration.esm.js';
import { inclusiveEndDateOf, inclusiveStartDateOf } from './duration.esm.js';
import { notEmpty } from './assert.esm.js';

const currencyFormatter = (currency) => {
  const options = currency.resolvedOptions();
  return new Intl.NumberFormat(options.locale, {
    style: "currency",
    currency: options.currency,
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  });
};
const lengthyCurrencyFormatter = (currency) => {
  const options = currency.resolvedOptions();
  return new Intl.NumberFormat(options.locale, {
    style: "currency",
    currency: options.currency,
    minimumFractionDigits: 0,
    minimumSignificantDigits: 2,
    maximumSignificantDigits: 2
  });
};
const numberFormatter = new Intl.NumberFormat("en-US", {
  minimumFractionDigits: 0,
  maximumFractionDigits: 0
});
const monthFormatter = new Intl.DateTimeFormat("en-US", {
  timeZone: "UTC",
  month: "long",
  year: "numeric"
});
const dateFormatter = new Intl.DateTimeFormat("en-US", {
  timeZone: "UTC",
  day: "numeric",
  month: "short"
});
const monthOf = (date) => {
  return monthFormatter.format(Date.parse(date));
};
const quarterOf = (date) => {
  const d = DateTime.fromISO(date).isValid ? DateTime.fromISO(date) : DateTime.fromFormat(date, "yyyy-'Q'q");
  return d.toFormat("'Q'q yyyy");
};
function formatCurrency(amount, currency) {
  const n = Math.round(amount);
  const numString = numberFormatter.format(n);
  return currency ? `${numString} ${pluralize(currency, n)}` : numString;
}
function formatChange(change, options) {
  if (notEmpty(change.ratio)) {
    return formatPercent(
      options?.absolute ? Math.abs(change.ratio) : change.ratio
    );
  }
  if (options?.absolute) {
    return "\u221E";
  }
  return change.amount >= 0 ? "\u221E" : "-\u221E";
}
function formatPercent(n) {
  if (isNaN(n) || Math.abs(n) < 0.01) {
    return "0%";
  }
  if (Math.abs(n) > 10) {
    return `>${n < 0 ? "-" : ""}1000%`;
  }
  return `${(n * 100).toFixed(0)}%`;
}
function formatLastTwoLookaheadQuarters(inclusiveEndDate) {
  const start = DateTime.fromISO(
    inclusiveStartDateOf(Duration.P3M, inclusiveEndDate)
  ).toFormat("'Q'q yyyy");
  const end = DateTime.fromISO(
    inclusiveEndDateOf(Duration.P3M, inclusiveEndDate)
  ).toFormat("'Q'q yyyy");
  return `${start} vs ${end}`;
}
const formatRelativePeriod = (duration, date, isEndDate) => {
  const periodStart = isEndDate ? inclusiveStartDateOf(duration, date) : date;
  const periodEnd = isEndDate ? date : inclusiveEndDateOf(duration, date);
  const days = Duration$1.fromISO(duration).days;
  if (![periodStart, periodEnd].includes(date)) {
    throw new Error(`Invalid relative date ${date} for duration ${duration}`);
  }
  return date === periodStart ? `First ${days} Days` : `Last ${days} Days`;
};
function formatPeriod(duration, date, isEndDate) {
  switch (duration) {
    case Duration.P3M:
      return quarterOf(
        isEndDate ? inclusiveEndDateOf(duration, date) : inclusiveStartDateOf(duration, date)
      );
    default:
      return formatRelativePeriod(duration, date, isEndDate);
  }
}

export { currencyFormatter, dateFormatter, formatChange, formatCurrency, formatLastTwoLookaheadQuarters, formatPercent, formatPeriod, lengthyCurrencyFormatter, monthFormatter, monthOf, numberFormatter, quarterOf };
//# sourceMappingURL=formatters.esm.js.map
