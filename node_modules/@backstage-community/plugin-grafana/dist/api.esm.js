import { createApiRef } from '@backstage/frontend-plugin-api';
import { QueryEvaluator } from './query/QueryEvaluator.esm.js';

const grafanaApiRef = createApiRef({
  id: "plugin.grafana.service"
});
const DEFAULT_PROXY_PATH = "/grafana/api";
const isSingleWord = (input) => {
  return input.match(/^[\w-]+$/g) !== null;
};
class Client {
  discoveryApi;
  fetchApi;
  proxyPath;
  queryEvaluator;
  constructor(opts) {
    this.discoveryApi = opts.discoveryApi;
    this.fetchApi = opts.fetchApi;
    this.proxyPath = opts.proxyPath ?? DEFAULT_PROXY_PATH;
    this.queryEvaluator = new QueryEvaluator();
  }
  async fetch(input, init) {
    const apiUrl = await this.apiUrl();
    const resp = await this.fetchApi.fetch(`${apiUrl}${input}`, init);
    if (!resp.ok) {
      throw new Error(`Request failed with ${resp.status} ${resp.statusText}`);
    }
    return await resp.json();
  }
  async listDashboards(domain, query) {
    if (isSingleWord(query)) {
      return this.dashboardsByTag(domain, query);
    }
    return this.dashboardsForQuery(domain, query);
  }
  async dashboardsForQuery(domain, query) {
    const parsedQuery = this.queryEvaluator.parse(query);
    const response = await this.fetch(`/api/search?type=dash-db`);
    const allDashboards = this.fullyQualifiedDashboardURLs(domain, response);
    return allDashboards.filter((dashboard) => {
      return this.queryEvaluator.evaluate(parsedQuery, dashboard) === true;
    });
  }
  async dashboardsByTag(domain, tag) {
    const response = await this.fetch(
      `/api/search?type=dash-db&tag=${tag}`
    );
    return this.fullyQualifiedDashboardURLs(domain, response);
  }
  fullyQualifiedDashboardURLs(domain, dashboards) {
    return dashboards.map((dashboard) => ({
      ...dashboard,
      url: domain + dashboard.url,
      folderUrl: domain + dashboard.folderUrl
    }));
  }
  async apiUrl() {
    const proxyUrl = await this.discoveryApi.getBaseUrl("proxy");
    return proxyUrl + this.proxyPath;
  }
}
class GrafanaApiClient {
  domain;
  client;
  constructor(opts) {
    this.domain = opts.domain;
    this.client = new Client(opts);
  }
  async listDashboards(query) {
    return this.client.listDashboards(this.domain, query);
  }
  async alertsForSelector(dashboardTag) {
    const response = await this.client.fetch(
      `/api/alerts?dashboardTag=${dashboardTag}`
    );
    return response.map((alert) => ({
      name: alert.name,
      state: alert.state,
      matchingSelector: dashboardTag,
      url: `${this.domain}${alert.url}?panelId=${alert.panelId}&fullscreen&refresh=30s`
    }));
  }
}
class UnifiedAlertingGrafanaApiClient {
  domain;
  client;
  constructor(opts) {
    this.domain = opts.domain;
    this.client = new Client(opts);
  }
  async listDashboards(query) {
    return this.client.listDashboards(this.domain, query);
  }
  async alertsForSelector(selectors) {
    let labelSelectors = [];
    if (typeof selectors === "string") {
      labelSelectors = [selectors];
    } else {
      labelSelectors = selectors;
    }
    const rulesResponse = await this.client.fetch("/api/ruler/grafana/api/v1/rules");
    const rules = Object.values(rulesResponse).flat().map((ruleGroup) => ruleGroup.rules).flat();
    const alertsResponse = await this.client.fetch(
      "/api/prometheus/grafana/api/v1/alerts"
    );
    return labelSelectors.map((selector) => {
      const [label, labelValue] = selector.split("=");
      const matchingRules = rules.filter(
        (rule) => rule.labels && rule.labels[label] === labelValue
      );
      const alertInstances = alertsResponse.data.alerts.filter(
        (alertInstance) => alertInstance.labels[label] === labelValue
      );
      return matchingRules.map((rule) => {
        const matchingAlertInstances = alertInstances.filter(
          (alertInstance) => alertInstance.labels.alertname === rule.grafana_alert.title
        );
        const aggregatedAlertStates = matchingAlertInstances.reduce(
          (previous, alert) => {
            switch (alert.state) {
              case "Normal":
                previous.Normal += 1;
                break;
              case "Pending":
                previous.Pending += 1;
                break;
              case "Alerting":
                previous.Alerting += 1;
                break;
              case "NoData":
                previous.NoData += 1;
                break;
              case "Error":
                previous.Error += 1;
                break;
              default:
                previous.Invalid += 1;
            }
            return previous;
          },
          {
            Normal: 0,
            Pending: 0,
            Alerting: 0,
            NoData: 0,
            Error: 0,
            Invalid: 0
          }
        );
        return {
          name: rule.grafana_alert.title,
          url: `${this.domain}/alerting/grafana/${rule.grafana_alert.uid}/view`,
          matchingSelector: selector,
          state: this.getState(
            aggregatedAlertStates,
            matchingAlertInstances.length
          )
        };
      });
    }).flat();
  }
  getState(states, totalAlerts) {
    if (states.Alerting > 0) {
      return "Alerting";
    } else if (states.Error > 0) {
      return "Error";
    } else if (states.Pending > 0) {
      return "Pending";
    }
    if (states.NoData === totalAlerts) {
      return "NoData";
    } else if (states.Normal === totalAlerts || states.Normal + states.NoData === totalAlerts) {
      return "Normal";
    }
    return "n/a";
  }
}

export { GrafanaApiClient, UnifiedAlertingGrafanaApiClient, grafanaApiRef };
//# sourceMappingURL=api.esm.js.map
