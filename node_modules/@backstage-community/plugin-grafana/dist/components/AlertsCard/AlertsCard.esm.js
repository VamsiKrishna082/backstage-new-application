import React from 'react';
import { Progress, Table, Link, StatusAborted, StatusError, StatusWarning, StatusPending, StatusOK } from '@backstage/core-components';
import { useEntity, MissingAnnotationEmptyState } from '@backstage/plugin-catalog-react';
import { useApi, configApiRef } from '@backstage/core-plugin-api';
import { grafanaApiRef } from '../../api.esm.js';
import useAsync from 'react-use/lib/useAsync';
import { Alert } from '@material-ui/lab';
import { isDashboardSelectorAvailable, GRAFANA_ANNOTATION_TAG_SELECTOR, isAlertSelectorAvailable, GRAFANA_ANNOTATION_ALERT_LABEL_SELECTOR, alertSelectorFromEntity, tagSelectorFromEntity } from '../../constants.esm.js';

const AlertStatusBadge = ({ alert }) => {
  let statusElmt;
  switch (alert.state) {
    case "ok":
    case "Normal":
      statusElmt = /* @__PURE__ */ React.createElement(StatusOK, null);
      break;
    case "paused":
    case "Pending":
      statusElmt = /* @__PURE__ */ React.createElement(StatusPending, null);
      break;
    case "no_data":
    case "pending":
    case "NoData":
      statusElmt = /* @__PURE__ */ React.createElement(StatusWarning, null);
      break;
    case "alerting":
    case "Alerting":
    case "Error":
      statusElmt = /* @__PURE__ */ React.createElement(StatusError, null);
      break;
    default:
      statusElmt = /* @__PURE__ */ React.createElement(StatusAborted, null);
  }
  return /* @__PURE__ */ React.createElement("div", null, statusElmt);
};
const AlertsTable = ({
  alerts,
  opts
}) => {
  const columns = [
    {
      title: "Name",
      field: "name",
      cellStyle: { width: "90%" },
      render: (row) => /* @__PURE__ */ React.createElement(Link, { to: row.url, target: "_blank", rel: "noopener" }, row.name)
    }
  ];
  if (opts.showState) {
    columns.push({
      title: "State",
      render: (row) => /* @__PURE__ */ React.createElement(AlertStatusBadge, { alert: row })
    });
  }
  return /* @__PURE__ */ React.createElement(
    Table,
    {
      title: opts.title || "Alerts",
      options: {
        paging: opts.paged ?? false,
        pageSize: opts.pageSize ?? 5,
        search: opts.searchable ?? false,
        emptyRowsWhenPaging: false,
        sorting: opts.sortable ?? false,
        draggable: false,
        padding: "dense"
      },
      data: alerts,
      columns
    }
  );
};
const Alerts = ({ entity, opts }) => {
  const grafanaApi = useApi(grafanaApiRef);
  const configApi = useApi(configApiRef);
  const unifiedAlertingEnabled = configApi.getOptionalBoolean("grafana.unifiedAlerting") || false;
  const alertSelector = unifiedAlertingEnabled ? alertSelectorFromEntity(entity) : tagSelectorFromEntity(entity);
  const { value, loading, error } = useAsync(
    async () => await grafanaApi.alertsForSelector(alertSelector)
  );
  if (loading) {
    return /* @__PURE__ */ React.createElement(Progress, null);
  } else if (error) {
    return /* @__PURE__ */ React.createElement(Alert, { severity: "error" }, error.message);
  }
  return /* @__PURE__ */ React.createElement(AlertsTable, { alerts: value || [], opts });
};
const AlertsCard = (opts) => {
  const { entity } = useEntity();
  const configApi = useApi(configApiRef);
  const unifiedAlertingEnabled = configApi.getOptionalBoolean("grafana.unifiedAlerting") || false;
  if (!unifiedAlertingEnabled && !isDashboardSelectorAvailable(entity)) {
    return /* @__PURE__ */ React.createElement(
      MissingAnnotationEmptyState,
      {
        annotation: GRAFANA_ANNOTATION_TAG_SELECTOR
      }
    );
  }
  if (unifiedAlertingEnabled && !isAlertSelectorAvailable(entity)) {
    return /* @__PURE__ */ React.createElement(
      MissingAnnotationEmptyState,
      {
        annotation: GRAFANA_ANNOTATION_ALERT_LABEL_SELECTOR
      }
    );
  }
  const finalOpts = { ...opts, ...{ showState: opts?.showState } };
  return /* @__PURE__ */ React.createElement(Alerts, { entity, opts: finalOpts });
};

export { AlertsCard, AlertsTable };
//# sourceMappingURL=AlertsCard.esm.js.map
