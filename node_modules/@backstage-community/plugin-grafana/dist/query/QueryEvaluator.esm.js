import jsep from 'jsep';

const includes = (haystack, needle) => {
  if (!Array.isArray(haystack)) {
    throw Error(`@> operator can only be used on an array`);
  }
  return haystack.includes(needle);
};
class QueryEvaluator {
  constructor() {
    jsep.addBinaryOp("@>", 6);
  }
  parse(query) {
    return jsep(query);
  }
  evaluate(root, context) {
    switch (root.type) {
      case "UnaryExpression":
        return this.evaluateUnaryExpression(
          root,
          context
        );
      case "BinaryExpression":
        return this.evaluateBinaryExpression(
          root,
          context
        );
      case "Identifier":
        if (!context.hasOwnProperty(root.name)) {
          throw Error(
            `identifier ${root.name} does not exist`
          );
        }
        return context[root.name];
      case "Literal":
        return root.value;
      default:
        throw Error(`unknown node type ${root.type}`);
    }
  }
  evaluateUnaryExpression(root, context) {
    switch (root.operator) {
      case "!":
        return !this.evaluate(root.argument, context);
      default:
        throw Error(`unknown unary operator ${root.operator}`);
    }
  }
  evaluateBinaryExpression(root, context) {
    switch (root.operator) {
      case "&&":
        return this.evaluate(root.left, context) && this.evaluate(root.right, context);
      case "||":
        return this.evaluate(root.left, context) || this.evaluate(root.right, context);
      case "==":
        return this.evaluate(root.left, context) === this.evaluate(root.right, context);
      case "!=":
        return this.evaluate(root.left, context) !== this.evaluate(root.right, context);
      case "@>":
        return includes(
          this.evaluate(root.left, context),
          this.evaluate(root.right, context)
        );
      default:
        throw Error(`unknown binary operator ${root.operator}`);
    }
  }
}

export { QueryEvaluator };
//# sourceMappingURL=QueryEvaluator.esm.js.map
