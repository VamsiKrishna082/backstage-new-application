'use strict';

var container = require('@google-cloud/container');
var pluginKubernetesCommon = require('@backstage/plugin-kubernetes-common');
var backendPluginApi = require('@backstage/backend-plugin-api');
var catalogModel = require('@backstage/catalog-model');

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var container__namespace = /*#__PURE__*/_interopNamespaceCompat(container);

class GkeEntityProvider {
  logger;
  scheduleFn;
  gkeParents;
  clusterManagerClient;
  connection;
  constructor(logger, taskRunner, gkeParents, clusterManagerClient) {
    this.logger = logger;
    this.scheduleFn = this.createScheduleFn(taskRunner);
    this.gkeParents = gkeParents;
    this.clusterManagerClient = clusterManagerClient;
  }
  static fromConfig({
    logger,
    scheduler,
    config
  }) {
    return GkeEntityProvider.fromConfigWithClient({
      logger,
      scheduler,
      config,
      clusterManagerClient: new container__namespace.v1.ClusterManagerClient()
    });
  }
  static fromConfigWithClient({
    logger,
    scheduler,
    config,
    clusterManagerClient
  }) {
    const gkeProviderConfig = config.getConfig("catalog.providers.gcp.gke");
    const schedule = backendPluginApi.readSchedulerServiceTaskScheduleDefinitionFromConfig(
      gkeProviderConfig.getConfig("schedule")
    );
    return new GkeEntityProvider(
      logger,
      scheduler.createScheduledTaskRunner(schedule),
      gkeProviderConfig.getStringArray("parents"),
      clusterManagerClient
    );
  }
  getProviderName() {
    return `gcp-gke`;
  }
  async connect(connection) {
    this.connection = connection;
    await this.scheduleFn();
  }
  filterOutUndefinedDeferredEntity(e) {
    return e !== void 0;
  }
  filterOutUndefinedCluster(c) {
    return c !== void 0 && c !== null;
  }
  clusterToResource(cluster, project) {
    const location = `${this.getProviderName()}:${cluster.location}`;
    if (!cluster.name || !cluster.selfLink || !cluster.endpoint || !cluster.location) {
      this.logger.warn(
        `ignoring partial cluster, one of name=${cluster.name}, endpoint=${cluster.endpoint}, selfLink=${cluster.selfLink} or location=${cluster.location} is missing`
      );
      return void 0;
    }
    return {
      locationKey: location,
      entity: {
        apiVersion: "backstage.io/v1alpha1",
        kind: "Resource",
        metadata: {
          annotations: {
            [pluginKubernetesCommon.ANNOTATION_KUBERNETES_API_SERVER]: `https://${cluster.endpoint}`,
            [pluginKubernetesCommon.ANNOTATION_KUBERNETES_API_SERVER_CA]: cluster.masterAuth?.clusterCaCertificate || "",
            [pluginKubernetesCommon.ANNOTATION_KUBERNETES_AUTH_PROVIDER]: "google",
            [pluginKubernetesCommon.ANNOTATION_KUBERNETES_DASHBOARD_APP]: "gke",
            [catalogModel.ANNOTATION_LOCATION]: location,
            [catalogModel.ANNOTATION_ORIGIN_LOCATION]: location,
            [pluginKubernetesCommon.ANNOTATION_KUBERNETES_DASHBOARD_PARAMETERS]: JSON.stringify({
              projectId: project,
              region: cluster.location,
              clusterName: cluster.name
            })
          },
          name: cluster.name,
          namespace: "default"
        },
        spec: {
          type: "kubernetes-cluster",
          owner: "unknown"
        }
      }
    };
  }
  createScheduleFn(taskRunner) {
    return async () => {
      const taskId = `${this.getProviderName()}:refresh`;
      return taskRunner.run({
        id: taskId,
        fn: async () => {
          try {
            await this.refresh();
          } catch (error) {
            this.logger.error(error);
          }
        }
      });
    };
  }
  async getClusters() {
    const clusters = await Promise.all(
      this.gkeParents.map(async (parent) => {
        const project = parent.split("/")[1];
        const request = {
          parent
        };
        const [response] = await this.clusterManagerClient.listClusters(
          request
        );
        return response.clusters?.filter(this.filterOutUndefinedCluster).map((c) => this.clusterToResource(c, project)).filter(this.filterOutUndefinedDeferredEntity) ?? [];
      })
    );
    return clusters.flat();
  }
  async refresh() {
    if (!this.connection) {
      throw new Error("Not initialized");
    }
    this.logger.info("Discovering GKE clusters");
    let resources;
    try {
      resources = await this.getClusters();
    } catch (e) {
      this.logger.error("error fetching GKE clusters", e);
      return;
    }
    this.logger.info(
      `Ingesting GKE clusters [${resources.map((r) => r.entity.metadata.name).join(", ")}]`
    );
    await this.connection.applyMutation({
      type: "full",
      entities: resources
    });
  }
}

exports.GkeEntityProvider = GkeEntityProvider;
//# sourceMappingURL=GkeEntityProvider.cjs.js.map
