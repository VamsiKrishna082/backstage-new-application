{"version":3,"file":"org.cjs.js","sources":["../../src/lib/org.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DEFAULT_NAMESPACE,\n  GroupEntity,\n  parseEntityRef,\n  stringifyEntityRef,\n  UserEntity,\n} from '@backstage/catalog-model';\n\nexport function buildOrgHierarchy(groups: GroupEntity[]) {\n  const groupsByName = new Map(groups.map(g => [g.metadata.name, g]));\n\n  //\n  // Make sure that g.parent.children contain g\n  //\n\n  for (const group of groups) {\n    const selfName = group.metadata.name;\n    const parentName = group.spec.parent;\n    if (parentName) {\n      const parent = groupsByName.get(parentName);\n      if (parent && !parent.spec.children.includes(selfName)) {\n        parent.spec.children.push(selfName);\n      }\n    }\n  }\n\n  //\n  // Make sure that g.children.parent is g\n  //\n\n  for (const group of groups) {\n    const selfName = group.metadata.name;\n    for (const childName of group.spec.children) {\n      const child = groupsByName.get(childName);\n      if (child && !child.spec.parent) {\n        child.spec.parent = selfName;\n      }\n    }\n  }\n}\n\n// Ensure that users have their direct group memberships.\nexport function assignGroupsToUsers(\n  users: UserEntity[],\n  groups: GroupEntity[],\n) {\n  const groupMemberUsers = new Map(\n    groups.map(group => {\n      const groupKey =\n        group.metadata.namespace &&\n        group.metadata.namespace !== DEFAULT_NAMESPACE\n          ? `${group.metadata.namespace}/${group.metadata.name}`\n          : group.metadata.name;\n      // Fully qualify member refs so they can be keyed off of since they may contain namespace prefixes\n      return [\n        groupKey,\n        group.spec.members?.map(m =>\n          stringifyEntityRef(parseEntityRef(m, { defaultKind: 'user' })),\n        ) || [],\n      ];\n    }),\n  );\n\n  const usersByRef = new Map(users.map(u => [stringifyEntityRef(u), u]));\n  for (const [groupName, userRefs] of groupMemberUsers.entries()) {\n    for (const ref of userRefs) {\n      const user = usersByRef.get(ref);\n      if (user && !user.spec.memberOf?.includes(groupName)) {\n        if (!user.spec.memberOf) {\n          user.spec.memberOf = [];\n        }\n        user.spec.memberOf.push(groupName);\n      }\n    }\n  }\n}\n\n// Ensure that users have their transitive group memberships. Requires that\n// the groups were previously processed with buildOrgHierarchy()\nexport function buildMemberOf(groups: GroupEntity[], users: UserEntity[]) {\n  const groupsByName = new Map(groups.map(g => [g.metadata.name, g]));\n\n  users.forEach(user => {\n    const transitiveMemberOf = new Set<string>();\n\n    const todo = [\n      ...(user.spec.memberOf ?? []),\n      ...groups\n        .filter(g => g.spec.members?.includes(user.metadata.name))\n        .map(g => g.metadata.name),\n    ];\n\n    for (;;) {\n      const current = todo.pop();\n      if (!current) {\n        break;\n      }\n\n      if (!transitiveMemberOf.has(current)) {\n        transitiveMemberOf.add(current);\n        const group = groupsByName.get(current);\n        if (group?.spec.parent) {\n          todo.push(group.spec.parent);\n        }\n      }\n    }\n\n    user.spec.memberOf = [...transitiveMemberOf];\n  });\n}\n"],"names":["DEFAULT_NAMESPACE","stringifyEntityRef","parseEntityRef"],"mappings":";;;;AAwBO,SAAS,kBAAkB,MAAuB,EAAA;AACvD,EAAA,MAAM,YAAe,GAAA,IAAI,GAAI,CAAA,MAAA,CAAO,GAAI,CAAA,CAAA,CAAA,KAAK,CAAC,CAAA,CAAE,QAAS,CAAA,IAAA,EAAM,CAAC,CAAC,CAAC,CAAA;AAMlE,EAAA,KAAA,MAAW,SAAS,MAAQ,EAAA;AAC1B,IAAM,MAAA,QAAA,GAAW,MAAM,QAAS,CAAA,IAAA;AAChC,IAAM,MAAA,UAAA,GAAa,MAAM,IAAK,CAAA,MAAA;AAC9B,IAAA,IAAI,UAAY,EAAA;AACd,MAAM,MAAA,MAAA,GAAS,YAAa,CAAA,GAAA,CAAI,UAAU,CAAA;AAC1C,MAAA,IAAI,UAAU,CAAC,MAAA,CAAO,KAAK,QAAS,CAAA,QAAA,CAAS,QAAQ,CAAG,EAAA;AACtD,QAAO,MAAA,CAAA,IAAA,CAAK,QAAS,CAAA,IAAA,CAAK,QAAQ,CAAA;AAAA;AACpC;AACF;AAOF,EAAA,KAAA,MAAW,SAAS,MAAQ,EAAA;AAC1B,IAAM,MAAA,QAAA,GAAW,MAAM,QAAS,CAAA,IAAA;AAChC,IAAW,KAAA,MAAA,SAAA,IAAa,KAAM,CAAA,IAAA,CAAK,QAAU,EAAA;AAC3C,MAAM,MAAA,KAAA,GAAQ,YAAa,CAAA,GAAA,CAAI,SAAS,CAAA;AACxC,MAAA,IAAI,KAAS,IAAA,CAAC,KAAM,CAAA,IAAA,CAAK,MAAQ,EAAA;AAC/B,QAAA,KAAA,CAAM,KAAK,MAAS,GAAA,QAAA;AAAA;AACtB;AACF;AAEJ;AAGgB,SAAA,mBAAA,CACd,OACA,MACA,EAAA;AACA,EAAA,MAAM,mBAAmB,IAAI,GAAA;AAAA,IAC3B,MAAA,CAAO,IAAI,CAAS,KAAA,KAAA;AAClB,MAAA,MAAM,WACJ,KAAM,CAAA,QAAA,CAAS,aACf,KAAM,CAAA,QAAA,CAAS,cAAcA,8BACzB,GAAA,CAAA,EAAG,KAAM,CAAA,QAAA,CAAS,SAAS,CAAI,CAAA,EAAA,KAAA,CAAM,SAAS,IAAI,CAAA,CAAA,GAClD,MAAM,QAAS,CAAA,IAAA;AAErB,MAAO,OAAA;AAAA,QACL,QAAA;AAAA,QACA,KAAA,CAAM,KAAK,OAAS,EAAA,GAAA;AAAA,UAAI,CAAA,CAAA,KACtBC,gCAAmBC,2BAAe,CAAA,CAAA,EAAG,EAAE,WAAa,EAAA,MAAA,EAAQ,CAAC;AAAA,aAC1D;AAAC,OACR;AAAA,KACD;AAAA,GACH;AAEA,EAAA,MAAM,UAAa,GAAA,IAAI,GAAI,CAAA,KAAA,CAAM,GAAI,CAAA,CAAA,CAAA,KAAK,CAACD,+BAAA,CAAmB,CAAC,CAAA,EAAG,CAAC,CAAC,CAAC,CAAA;AACrE,EAAA,KAAA,MAAW,CAAC,SAAW,EAAA,QAAQ,CAAK,IAAA,gBAAA,CAAiB,SAAW,EAAA;AAC9D,IAAA,KAAA,MAAW,OAAO,QAAU,EAAA;AAC1B,MAAM,MAAA,IAAA,GAAO,UAAW,CAAA,GAAA,CAAI,GAAG,CAAA;AAC/B,MAAA,IAAI,QAAQ,CAAC,IAAA,CAAK,KAAK,QAAU,EAAA,QAAA,CAAS,SAAS,CAAG,EAAA;AACpD,QAAI,IAAA,CAAC,IAAK,CAAA,IAAA,CAAK,QAAU,EAAA;AACvB,UAAK,IAAA,CAAA,IAAA,CAAK,WAAW,EAAC;AAAA;AAExB,QAAK,IAAA,CAAA,IAAA,CAAK,QAAS,CAAA,IAAA,CAAK,SAAS,CAAA;AAAA;AACnC;AACF;AAEJ;;;;;"}