'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var rootHttpRouter = require('@backstage/backend-defaults/rootHttpRouter');
var express = require('express');
var Router = require('express-promise-router');
var fs = require('fs');
var child_process = require('child_process');
var backendPluginApi = require('@backstage/backend-plugin-api');
var os = require('os');
var path = require('path');
var alpha = require('@backstage/plugin-catalog-node/alpha');
var pluginKubernetesBackend = require('@backstage/plugin-kubernetes-backend');
var luxon = require('luxon');
var pluginKubernetesCommon = require('@backstage/plugin-kubernetes-common');
var yaml = require('js-yaml');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var express__default = /*#__PURE__*/_interopDefaultLegacy(express);
var Router__default = /*#__PURE__*/_interopDefaultLegacy(Router);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var os__default = /*#__PURE__*/_interopDefaultLegacy(os);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var yaml__default = /*#__PURE__*/_interopDefaultLegacy(yaml);

async function createRouter(options) {
  const {
    logger,
    config,
    kubernetesBuilder,
    httpAuth,
    kubeconfigPath,
    headlampBinaryPath,
    pluginsPath
  } = options;
  const router = Router__default["default"]();
  let headlampProcess = null;
  logger.info("Creating Headlamp Server router");
  router.use(express__default["default"].json());
  router.get("/health", (_, response) => {
    response.json({ status: "ok" });
  });
  router.post("/refreshKubeconfig", async (req, res) => {
    try {
      const credentials = await httpAuth.credentials(req);
      const requestBody = req.body;
      const auth = requestBody.auth;
      const kubeconfig = await kubernetesBuilder.getKubeconfig(credentials, auth);
      fs__default["default"].writeFileSync(kubeconfigPath, kubeconfig);
      res.json({ status: "ok" });
    } catch (error) {
      logger.error(`Error refreshing kubeconfig: ${error}`);
      res.status(500).json({ message: "Error refreshing kubeconfig" });
    }
  });
  router.post("/start", async (req, res) => {
    try {
      const credentials = await httpAuth.credentials(req);
      const requestBody = req.body;
      const auth = requestBody.auth;
      if (!headlampProcess) {
        headlampProcess = await spawnHeadlamp(
          logger,
          credentials,
          kubernetesBuilder,
          auth,
          headlampBinaryPath,
          kubeconfigPath,
          pluginsPath
        );
        res.json({ message: "Headlamp Server started" });
      } else {
        logger.info("Headlamp Server already running, refreshing kubeconfig");
        const kubeconfig = await kubernetesBuilder.getKubeconfig(credentials, auth);
        fs__default["default"].writeFileSync(kubeconfigPath, kubeconfig);
        res.json({ message: "Headlamp Server kubeconfig refreshed" });
      }
    } catch (error) {
      logger.error(`Error starting Headlamp Server: ${error}`);
      res.status(500).json({ message: "Error starting Headlamp Server" });
    }
  });
  const middleware = rootHttpRouter.MiddlewareFactory.create({ logger, config });
  router.use(middleware.error());
  return router;
}
async function spawnHeadlamp(logger, credentials, kubernetesBuilder, auth, headlampBinaryPath, kubeconfigPath, pluginsPath) {
  try {
    const kubeconfig = await kubernetesBuilder.getKubeconfig(credentials, auth);
    fs__default["default"].writeFileSync(kubeconfigPath, kubeconfig);
  } catch (error) {
    logger.error(`Error creating kubeconfig from kubernetes config: ${error}`);
  }
  const headlampProcess = child_process.spawn(headlampBinaryPath, [
    "--kubeconfig",
    kubeconfigPath,
    "--plugins-dir",
    pluginsPath
  ]);
  headlampProcess.stdout.on("data", (data) => {
    logger.info(`Headlamp Server stdout: ${data}`);
  });
  headlampProcess.stderr.on("data", (data) => {
    logger.error(`Headlamp Server stderr: ${data}`);
  });
  return headlampProcess;
}

function combineKubeconfigs(kubeconfigs) {
  const combinedConfig = {
    apiVersion: "v1",
    kind: "Config",
    clusters: [],
    users: [],
    contexts: []
  };
  kubeconfigs.forEach((config) => {
    combinedConfig.clusters.push(...config.clusters);
    combinedConfig.users.push(...config.users);
    combinedConfig.contexts.push(...config.contexts);
  });
  if (combinedConfig.contexts.length > 0) {
    combinedConfig["current-context"] = combinedConfig.contexts[0].name;
  }
  return yaml__default["default"].dump(combinedConfig, {
    lineWidth: -1,
    // Disable line wrapping
    noRefs: true,
    // Avoid aliases for repeated nodes
    quotingType: '"'
    // Use double quotes for strings
  });
}

class HeadlampKubernetesBuilder extends pluginKubernetesBackend.KubernetesBuilder {
  /**
   * Lists details for all configured Kubernetes clusters
   * @param {BackstageCredentials} credentials - The Backstage credentials for authentication
   * @returns {Promise<Array<{name: string, url: string, skipTLSVerify: boolean, credential: KubernetesCredential, caData: string}>>} 
   * Array of cluster details including connection info and credentials
   */
  async listClusterDetails(credentials, auth) {
    const duration = luxon.Duration.fromObject({
      minutes: 1
    });
    const clusterSupplier = this.buildClusterSupplier(duration);
    const clusterDetails = await clusterSupplier.getClusters({ credentials });
    const clusterInfo = clusterDetails.map(async (cd) => {
      var _a;
      const oidcTokenProvider = cd.authMetadata[pluginKubernetesCommon.ANNOTATION_KUBERNETES_OIDC_TOKEN_PROVIDER];
      const authProvider = cd.authMetadata[pluginKubernetesCommon.ANNOTATION_KUBERNETES_AUTH_PROVIDER];
      const authStrategyMap = this.getAuthStrategyMap();
      const currentAuthStrategy = authStrategyMap[authProvider];
      const currentCredential = await currentAuthStrategy.getCredential(
        cd,
        auth
      );
      return {
        name: cd.name,
        url: cd.url,
        skipTLSVerify: (_a = cd.skipTLSVerify) != null ? _a : false,
        title: cd.title,
        caData: cd.caData,
        credential: currentCredential,
        authProvider,
        ...oidcTokenProvider && { oidcTokenProvider },
        ...auth && Object.keys(auth).length !== 0 && { auth }
      };
    });
    return Promise.all(clusterInfo).then(
      (clusters) => clusters.map((cluster) => ({
        name: cluster.name,
        url: cluster.url,
        skipTLSVerify: cluster.skipTLSVerify,
        credential: cluster.credential,
        caData: cluster.caData || ""
      }))
    );
  }
  /**
   * Converts a cluster details object into a kubeconfig format
   * @param {Object} cluster - The cluster details object
   * @param {string} cluster.name - Name of the cluster
   * @param {string} cluster.url - URL of the cluster API server
   * @param {boolean} cluster.skipTLSVerify - Whether to skip TLS verification
   * @param {KubernetesCredential} cluster.credential - Credentials for cluster authentication
   * @param {string} cluster.caData - Certificate authority data
   * @returns {Kubeconfig} Kubeconfig object for the cluster
   * @private
   */
  convertClusterToKubeconfig(cluster) {
    const kubeconfig = {
      apiVersion: "v1",
      kind: "Config",
      clusters: [
        {
          name: cluster.name,
          cluster: {
            server: cluster.url,
            "insecure-skip-tls-verify": cluster.skipTLSVerify,
            "certificate-authority-data": cluster.caData
          }
        }
      ],
      users: [
        {
          name: cluster.name,
          user: {}
        }
      ],
      contexts: [
        {
          name: cluster.name,
          context: {
            cluster: cluster.name,
            user: cluster.name
          }
        }
      ],
      "current-context": cluster.name
    };
    switch (cluster.credential.type) {
      case "bearer token":
        kubeconfig.users[0].user.token = cluster.credential.token;
        break;
      case "x509 client certificate":
        kubeconfig.users[0].user = {
          "client-certificate-data": cluster.credential.cert,
          "client-key-data": cluster.credential.key
        };
        break;
    }
    return kubeconfig;
  }
  /**
   * Generates a complete kubeconfig file string for all configured clusters
   * @param {BackstageCredentials} credentials - The Backstage credentials for authentication
   * @returns {Promise<string>} Combined kubeconfig file contents as a string
   */
  async getKubeconfig(credentials, auth) {
    const clusters = await this.listClusterDetails(credentials, auth);
    const kubeconfigs = clusters.map(
      (cluster) => this.convertClusterToKubeconfig(cluster)
    );
    return combineKubeconfigs(kubeconfigs);
  }
}

const headlampPlugin = backendPluginApi.createBackendPlugin({
  pluginId: "headlamp",
  register(env) {
    env.registerInit({
      deps: {
        httpRouter: backendPluginApi.coreServices.httpRouter,
        logger: backendPluginApi.coreServices.logger,
        config: backendPluginApi.coreServices.rootConfig,
        discovery: backendPluginApi.coreServices.discovery,
        catalogApi: alpha.catalogServiceRef,
        permissions: backendPluginApi.coreServices.permissions,
        auth: backendPluginApi.coreServices.auth,
        httpAuth: backendPluginApi.coreServices.httpAuth
      },
      async init({ httpRouter, logger, config, discovery, catalogApi, permissions, auth, httpAuth }) {
        const kubeconfigPath = path__default["default"].join(os__default["default"].tmpdir(), "kubeconfig.yaml");
        const headlampBinaryPath = config.getOptionalString("headlampBackend.binaryPath") || path__default["default"].join(process.cwd(), "bin", process.platform === "win32" ? "headlamp-standalone.exe" : "headlamp-standalone");
        const pluginsPath = config.getOptionalString("headlampBackend.pluginsPath") || path__default["default"].join(process.cwd(), "plugins");
        logger.info(`Headlamp Binary Path: ${headlampBinaryPath}`);
        logger.info(`Kubeconfig Path: ${kubeconfigPath}`);
        const builder = new HeadlampKubernetesBuilder({
          logger,
          config,
          discovery,
          catalogApi,
          permissions,
          auth,
          httpAuth
        });
        httpRouter.use(
          await createRouter({
            logger,
            config,
            kubernetesBuilder: builder,
            httpAuth,
            kubeconfigPath,
            headlampBinaryPath,
            pluginsPath
          })
        );
        httpRouter.addAuthPolicy({
          path: "/health",
          allow: "unauthenticated"
        });
      }
    });
  }
});

exports.createRouter = createRouter;
exports["default"] = headlampPlugin;
//# sourceMappingURL=index.cjs.js.map
