import React, { useState, useEffect, useCallback } from 'react';
import { Progress } from '@backstage/core-components';
import { useNavigate, useLocation } from 'react-router-dom';
import { useApi, configApiRef } from '@backstage/core-plugin-api';
import { h as headlampApiRef } from './index-668854a6.esm.js';
import { kubernetesApiRef, kubernetesAuthProvidersApiRef } from '@backstage/plugin-kubernetes-react';

function HeadlampComponent() {
  const config = useApi(configApiRef);
  const headlampApi = useApi(headlampApiRef);
  const [isLoaded, setIsLoaded] = useState(false);
  const refreshInterval = 5e3;
  const [isStandalone, setIsStandalone] = useState(true);
  const kubernetesApi = useApi(kubernetesApiRef);
  const kubernetesAuthProvidersApi = useApi(kubernetesAuthProvidersApiRef);
  const fetchAuthTokenMap = async () => {
    const clusters = await kubernetesApi.getClusters();
    const clusterNames = [];
    clusters.forEach((c) => {
      clusterNames.push(
        `${c.authProvider}${c.oidcTokenProvider ? `.${c.oidcTokenProvider}` : ""}`
      );
    });
    const authTokenMap = {};
    for (const clusterName of clusterNames) {
      const auth = await kubernetesAuthProvidersApi.getCredentials(clusterName);
      authTokenMap[clusterName] = auth.token;
    }
    return authTokenMap;
  };
  useEffect(() => {
    const checkHealth = async () => {
      const res = await headlampApi.health();
      const standalone = (res == null ? void 0 : res.status) !== "ok";
      setIsStandalone(standalone);
      if (!standalone) {
        const authTokenMap = await fetchAuthTokenMap();
        console.log("Starting Headlamp server");
        headlampApi.startServer(authTokenMap);
      }
    };
    checkHealth();
  }, [headlampApi]);
  const headlampUrl = config.getOptionalString("headlamp.url") || `${window.location.protocol}//${window.location.hostname}:4466`;
  const navigate = useNavigate();
  const location = useLocation();
  useEffect(() => {
    const checkHeadlampReady = async () => {
      try {
        const response = await fetch(`${headlampUrl}`);
        if (response.ok) {
          setIsLoaded(true);
        } else {
          throw new Error(`Headlamp not ready: ${response.statusText}`);
        }
      } catch (err) {
        console.error("Failed to check Headlamp readiness:", err);
      }
    };
    if (!isLoaded) {
      checkHeadlampReady();
      const timer = setInterval(checkHeadlampReady, refreshInterval);
      return () => clearInterval(timer);
    }
    return void 0;
  }, [isLoaded, headlampUrl]);
  const handleMessage = useCallback(
    (event) => {
      if (event.origin !== new URL(headlampUrl).origin)
        return;
      const data = event.data;
      if (data.redirectPath) {
        navigate(data.redirectPath);
      }
    },
    [headlampUrl, navigate]
  );
  useEffect(() => {
    window.addEventListener("message", handleMessage);
    return () => window.removeEventListener("message", handleMessage);
  }, [handleMessage]);
  useEffect(() => {
    if (!isStandalone) {
      const refreshKubeconfigPeriodically = async () => {
        const authTokenMap = await fetchAuthTokenMap();
        console.log("Refreshing kubeconfig");
        await headlampApi.refreshKubeconfig(authTokenMap);
      };
      refreshKubeconfigPeriodically();
      const intervalId = setInterval(refreshKubeconfigPeriodically, 6e4);
      return () => clearInterval(intervalId);
    }
    return void 0;
  }, [isStandalone, headlampApi]);
  if (!isLoaded) {
    return /* @__PURE__ */ React.createElement(Progress, null);
  }
  const queryParams = new URLSearchParams(location.search).toString();
  const iframeSrc = queryParams ? `${headlampUrl}?${queryParams}` : headlampUrl;
  return /* @__PURE__ */ React.createElement(
    "iframe",
    {
      src: iframeSrc,
      title: "Headlamp",
      style: {
        width: "100%",
        height: "100vh",
        border: "none"
      }
    }
  );
}

export { HeadlampComponent };
//# sourceMappingURL=index-cc6d4405.esm.js.map
