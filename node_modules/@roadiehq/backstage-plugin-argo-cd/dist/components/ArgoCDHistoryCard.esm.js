import { ErrorBoundary, InfoCard } from '@backstage/core-components';
import { useApi, configApiRef } from '@backstage/core-plugin-api';
import { useEntity, MissingAnnotationEmptyState } from '@backstage/plugin-catalog-react';
import { LinearProgress } from '@material-ui/core';
import React, { useState, useEffect } from 'react';
import { isArgocdAvailable } from '../conditions.esm.js';
import { useAppDetails } from './useAppDetails.esm.js';
import { ARGOCD_ANNOTATION_APP_NAME, useArgoCDAppData } from './useArgoCDAppData.esm.js';
import { argoCDApiRef } from '../api/index.esm.js';
import { ArgoCDHistoryTable } from './ArgoCDHistoryTable.esm.js';

const isHelmChart = (row) => {
  return row.source?.chart !== void 0;
};
const getRevisionId = (row) => {
  if (row.revision.hasOwnProperty("revisionID")) {
    return row.revision.revisionID;
  }
  return row.revision;
};
const withRevisionDetails = async (api, url, row) => {
  if (isHelmChart(row)) {
    row.revisionDetails = { author: "n/a", message: "n/a", date: "n/a" };
    return row;
  }
  row.revisionDetails = await api.getRevisionDetails({
    url,
    app: row.app,
    appNamespace: row.appNamespace,
    revisionID: getRevisionId(row),
    instanceName: row.instance
  });
  return row;
};
const ArgoCDHistory = ({ entity }) => {
  const [tableRows, setTableRows] = useState([]);
  const argoCDApi = useApi(argoCDApiRef);
  const { url, appName, appSelector, appNamespace, projectName } = useArgoCDAppData({ entity });
  const { loading, value, error, retry } = useAppDetails({
    url,
    appName,
    appSelector,
    appNamespace,
    projectName
  });
  const revisionsToLoad = useApi(configApiRef).getOptionalNumber("argocd.revisionsToLoad") || -1;
  useEffect(() => {
    if (!value) {
      return;
    }
    let apps;
    if (value.items !== void 0) {
      apps = value.items ?? [];
    } else if (Array.isArray(value)) {
      apps = value;
    } else {
      apps = [value];
    }
    const revisions = apps.filter((app) => app?.status?.history).flatMap((app) => {
      return app.status.history.sort(
        (a, b) => new Date(b.deployedAt || "").valueOf() - new Date(a.deployedAt || "").valueOf()
      ).slice(0, revisionsToLoad).map((entry) => ({
        key: `${app.metadata.name}-${entry.revision}`,
        app: app.metadata.name,
        appNamespace: app.metadata.namespace,
        instance: app.metadata?.instance?.name,
        ...entry
      }));
    });
    setTableRows(revisions);
    Promise.all(
      revisions.map(
        async (row) => await withRevisionDetails(argoCDApi, url, row)
      )
    ).then((rowsWithRevisions) => {
      setTableRows(rowsWithRevisions.filter((row) => row));
    });
  }, [value, argoCDApi, url, revisionsToLoad]);
  if (loading) {
    return /* @__PURE__ */ React.createElement(InfoCard, { title: "ArgoCD history" }, /* @__PURE__ */ React.createElement(LinearProgress, null));
  }
  if (error) {
    return /* @__PURE__ */ React.createElement(InfoCard, { title: "ArgoCD history" }, "Error occurred while fetching data. ", error.message);
  }
  if (tableRows.length) {
    return /* @__PURE__ */ React.createElement(ArgoCDHistoryTable, { data: tableRows, retry });
  }
  return null;
};
const ArgoCDHistoryCard = () => {
  const { entity } = useEntity();
  return !isArgocdAvailable(entity) ? /* @__PURE__ */ React.createElement(MissingAnnotationEmptyState, { annotation: ARGOCD_ANNOTATION_APP_NAME }) : /* @__PURE__ */ React.createElement(ErrorBoundary, null, /* @__PURE__ */ React.createElement(ArgoCDHistory, { entity }));
};

export { ArgoCDHistoryCard };
//# sourceMappingURL=ArgoCDHistoryCard.esm.js.map
